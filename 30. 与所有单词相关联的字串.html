<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>30. 与所有单词相关联的字串</title>
</head>

<body>
  <script>
    /*
                          给定一个字符串 s 和一些长度相同的单词 words。在 s 中找出可以恰好串联 words 中所有单词的子串的起始位置。

                          注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。

                          示例 1:

                          输入:
                          s = "barfoothefoobarman",
                          words = ["foo","bar"]
                          输出: [0,9]
                          解释: 从索引 0 和 9 开始的子串分别是 "barfoor" 和 "foobar" 。
                          输出的顺序不重要, [9,0] 也是有效答案。
                          示例 2:

                          输入:
                          s = "wordgoodstudentgoodword",
                          words = ["word","student"]
                          输出: []
                  */

    var count = 0;

    function show(arr) {
      document.write("P<sub>" + ++count + "</sub>: " + arr + "<br />");
    }

    function perm(arr) {
      let res = []
      (function fn(source, result) {
        if (source.length == 0)
          res.push(result)
        else
          for (var i = 0; i < source.length; i++) {
            fn(source.slice(0, i).concat(source.slice(i + 1)), result.concat(source[i]))
          }
      })(arr, [])
      console.log(res);
    }

    let res = perm(["word", "good", "best", "word"])
    // var findSubstring = function(s, words) {
    //   let obj = {}
    //   let arr = permute([], words)
    //   console.log(words, arr)
    //   // for (let i = 0; i < arr.length; i++) {
    //   //   let str =
    //   //   if (s.indexOf(str) != -1) {
    //   //     arr.push(s.indexOf(k))
    //   //   }
    //   // }
    //   // return [...new Set(arr)]
    // }
    // let res = findSubstring("wordgoodgoodgoodbestword", ["word", "good", "best", "word"])
    console.log(res)
  </script>
</body>

</html>
